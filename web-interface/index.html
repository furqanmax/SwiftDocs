<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Dynamic Document Editor</title>
    <!-- Include a modern font similar to Notion -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
    />
    <style>
      /* Core styles updated for a Notion-like interface */
      body {
        font-family: "Inter", sans-serif;
        background: #f7f8fa;
        padding: 40px;
        color: #333;
      }
      h1 {
        text-align: center;
        font-weight: 600;
        margin-bottom: 30px;
      }
      /* Editor styling to mimic Notion's clean document area */
      #editor {
        min-height: 600px;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        padding: 40px;
        margin-bottom: 40px;
      }
      .draggable {
        cursor: move;
        margin: 20px 0;
        padding: 10px 15px;
        border-left: 4px solid transparent;
        transition: border-color 0.2s, background 0.2s;
      }
      .draggable:hover {
        border-left-color: #007bff;
        background: #f0f8ff;
      }
      .draggable:focus {
        outline: none;
        border-left-color: #007bff;
      }
      /* Toolbar styling */
      .toolbar {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }
      .toolbar button {
        border: none;
        border-radius: 4px;
        background: #007bff;
        color: #fff;
        padding: 8px 16px;
        transition: background 0.2s;
      }
      .toolbar button:hover {
        background: #0056b3;
      }
      /* Saved elements list styles */
      #savedElements {
        max-width: 100%;
        margin: 0 auto;
      }
      .saved-element {
        border: 1px solid #e0e0e0;
        background: #fff;
        border-radius: 4px;
        padding: 15px;
        margin: 10px 0;
      }
      .saved-element:hover {
        cursor: pointer;
        background: #f0f8ff;
      }
      .saved-element strong {
        display: block;
        margin-bottom: 5px;
        color: #555;
      }
      .saved-element .editable {
        padding: 5px;
        border: 1px dashed transparent;
      }
      .saved-element .editable:focus {
        border-color: #007bff;
      }
      /* Two-column layout */
      .col-editor {
        border-right: 1px solid #ddd;
      }
    </style>
  </head>
  <body>
    <div class="container my-4">
      <h1>Dynamic Document Editor</h1>
      <div class="row">
        <!-- Left Column: Document Editor (9) -->
        <div class="col-md-9 col-editor">
          <!-- Toolbar -->
          <div class="toolbar d-flex justify-content-between">
            <div>
              <button id="addHeading">Heading</button>
              <button id="addSubheading">Sub-heading</button>
              <button id="addParagraph">Paragraph</button>
              <button id="addBullet">Bullet List</button>
            </div>
            <button id="saveContent" class="btn btn-success">
              Save Document
            </button>
          </div>
          <!-- Editable Document Area -->
          <div id="editor" ondragover="event.preventDefault()">
            <!-- New elements added here. Reorder via drag & drop. -->
          </div>
        </div>
        <!-- Right Column: Saved Elements List (3) -->
        <div class="col-md-3">
          <h3>Saved Elements</h3>
          <!-- NEW: Search input to filter saved elements -->
          <input type="text" id="searchInput" class="form-control mb-3" placeholder="Search elements..." />
          <ul id="savedElements" class="list-unstyled">
            <!-- Dynamically loaded saved elements will be inserted here -->
          </ul>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.10.2/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      // Initialize sortable for the editor with handle for dragging blocks
      Sortable.create(editor, { animation: 150, handle: '.handle' });
      
      // Modified createElement to wrap each new element in a container with a drag handle
      function createElement(type, content = null) {
        const container = document.createElement("div");
        container.classList.add("draggable");
        container.setAttribute("tabindex", "0");
        
        // Create and append a drag handle
        const handle = document.createElement("span");
        handle.className = "handle";
        handle.textContent = "â‹®";
        container.appendChild(handle);
        
        let elem;
        switch (type) {
          case "heading":
            elem = document.createElement("h1");
            elem.textContent = content || "New Heading";
            break;
          case "subheading":
            elem = document.createElement("h3");
            elem.textContent = content || "New Sub-heading";
            break;
          case "paragraph":
            elem = document.createElement("p");
            if (content) {
              elem.innerHTML = content;
            } else {
              elem.textContent = "New paragraph...";
            }
            break;
          case "bullet":
            elem = document.createElement("ul");
            const li = document.createElement("li");
            li.textContent = content || "Bullet point";
            elem.appendChild(li);
            break;
          default:
            return;
        }
        elem.contentEditable = true;
        elem.addEventListener("click", e => e.stopPropagation());
        container.appendChild(elem);
        editor.appendChild(container);
      }

      // Toolbar button event listeners
      document
        .getElementById("addHeading")
        .addEventListener("click", () => createElement("heading"));
      document
        .getElementById("addSubheading")
        .addEventListener("click", () => createElement("subheading"));
      document
        .getElementById("addParagraph")
        .addEventListener("click", () => createElement("paragraph"));
      document
        .getElementById("addBullet")
        .addEventListener("click", () => createElement("bullet"));

      // Save the entire document (the content of the editor) as a custom element on the server
      document.getElementById("saveContent").addEventListener("click", () => {
        const content = editor.innerHTML;
        fetch("http://localhost:3000/api/elements", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ type: "custom", content }),
        })
          .then((response) => response.json())
          .then((data) => {
            alert("Document saved successfully!");
            loadSavedElements(); // Refresh saved elements view
          })
          .catch((error) => console.error("Error saving document:", error));
      });

      // Load and display saved elements (both custom documents and others)
      async function loadSavedElements() {
        try {
          const res = await fetch("http://localhost:3000/api/elements");
          let data = await res.json();
          // Sort elements in descending order based on id
          data.sort((a, b) => b.id - a.id);
          // Filter by search query if provided
          const searchValue = document.getElementById("searchInput").value.toLowerCase();
          if (searchValue) {
            data = data.filter(el => {
              let contentStr = "";
              if (el.type === "html-css") {
                contentStr = el.content.html;
              } else {
                contentStr = typeof el.content === "string" ? el.content : JSON.stringify(el.content);
              }
              return el.type.toLowerCase().includes(searchValue) || contentStr.toLowerCase().includes(searchValue);
            });
          }
          const list = document.getElementById("savedElements");
          list.innerHTML = "";
          data.forEach((el) => {
            if (el.type !== "custom") {
              const li = document.createElement("li");
              li.className = "saved-element";
              li.dataset.id = el.id;
              let contentHtml = "";
              if (el.type === "screenshot") {
                contentHtml = `<img src="${el.content}" alt="Screenshot" style="max-width:100%;" />`;
              } else if (el.type === "html-css") {
                contentHtml = el.content.html;
              } else {
                contentHtml = el.content;
              }
              li.innerHTML = `
                <strong>${el.type}</strong>
                <div class="editable" contenteditable="false">${contentHtml}</div>
                <button class="btn btn-sm btn-primary mt-2" onclick="saveEdit(${el.id}, this)">Save</button>
              `;
              // On click, insert the saved element into the document editor
              li.addEventListener("click", () => {
                insertSavedElement(el);
              });
              list.appendChild(li);
            }
          });
          Sortable.create(list, {
            animation: 150,
            onEnd: updateSavedOrder,
          });
        } catch (error) {
          console.error("Error fetching saved elements:", error);
        }
      }

      // NEW: Function to insert a saved element into the editor
      function insertSavedElement(elementData) {
        let htmlContent = "";
        if (elementData.type === "screenshot") {
          htmlContent = `<img src="${elementData.content}" alt="Screenshot" style="max-width:100%;" />`;
          // Insert as a custom block:
          createElement("paragraph", htmlContent);
        } else if (elementData.type === "html-css") {
          htmlContent = elementData.content.html;
          createElement("paragraph", htmlContent);
        } else if (elementData.type === "custom") {
          htmlContent = elementData.content;
          // Append custom document content
          editor.innerHTML += htmlContent;
        } else {
          htmlContent = elementData.content;
          // Fallback: insert as paragraph
          createElement("paragraph", htmlContent);
        }
      }

      // Save edited content for a saved element
      async function saveEdit(id, btn) {
        const li = btn.parentElement;
        const newContent = li.querySelector(".editable").innerText;
        try {
          await fetch(`http://localhost:3000/api/elements/${id}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ content: newContent }),
          });
          alert("Saved!");
          loadSavedElements();
        } catch (error) {
          console.error("Error saving edit:", error);
        }
      }

      // Update order of saved elements based on drag/drop
      async function updateSavedOrder() {
        const list = document.getElementById("savedElements");
        const order = [...list.children].map((li) => Number(li.dataset.id));
        try {
          await fetch("http://localhost:3000/api/elements/reorder", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ order }),
          });
          loadSavedElements();
        } catch (error) {
          console.error("Error updating order:", error);
        }
      }

      // NEW: Listen for search input changes to filter saved elements dynamically
      document.getElementById("searchInput").addEventListener("input", loadSavedElements);

      // Load saved elements on page load
      window.onload = () => {
        loadSavedElements();
      };
    </script>
  </body>
</html>
